<!--
    Simple platform game created by me to learn how to use Canvas on Javascript
    Created by: Erik Ricku  
    Date: 2025/05/13
    GitHub: https://github.com/WikiErik
-->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas Platform</title>
    <style>
        body { margin: 0; display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100vh; background-color: #f0f0f0; }
        canvas { border: 1px solid black; background-color: #ffffff; }
        #GameOverText { margin-top: 15px; font-size: 24px; font-weight: bold; color: #333; text-align: center;}
    </style>
</head>
<body>

    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="GameOverText"></div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameovertext = document.getElementById('GameOverText');

        // --- World Object ---
        const world = {
            width: 1600,
            height: canvas.height // Or a fixed value like 600 if world height is fixed
        };

        // --- Camera Object ---
        const camera = {
            x: 0,
            y: 0,
            width: canvas.width,  
            height: canvas.height 
        };

        // --- Game State ---
        let gameState = "initial"; // "initial", "playing", "gameOver"

        // --- Timer Variables ---
        let startTime = 0;
        let finalTime = 0;
        // --- Display Time (global for draw function) ---
        let displayTimeSeconds = 0; // Initialize it


        // --- Player Object ---
        const player = {
            x: 50, y: 50, width: 40, height: 40, color: 'blue',
            speed: 4, dx: 0, velocityY: 0, gravity: 0.6,
            jumpStrength: 13,
            isGrounded: false
        };

        // --- Platforms ---
       const platforms = [
                { x: 100, y: world.height - 70, width: 200, height: 20, color: 'green', goal: false },
                {
                    x: 350, y: world.height - 150, width: 150, height: 20, color: 'DodgerBlue', goal: false,
                    isMoving: true, // Flag it as a moving platform
                    moveSpeed: 1,   // How fast it moves
                    direction: 1,   // 1 for right/down, -1 for left/up
                    startX: 350,    // Original X, to calculate movement range
                    moveRangeX: 100 // How far it moves horizontally from its startX before turning
                },
                { x: 50,  y: world.height - 250, width: 100, height: 20, color: 'purple', goal: false },
                { x: 600, y: world.height - 100, width: 180, height: 20, color: 'teal', goal: false},
                { x: 900, y: world.height - 200, width: 150, height: 20, color: 'pink', goal: false},
                { x: 1200, y: world.height - 300, width: 250, height: 20, color: 'brown', goal: true}
            ];
        // --- Keyboard Input State ---
        const keysPressed = {};

        if (ctx && gameovertext) {
            console.log("Canvas and context are ready!");

            // --- Event Listeners ---
            window.addEventListener('keydown', function(event) {
                if (gameState === "initial") {
                    runGame();
                } else if (gameState === "playing") {
                    keysPressed[event.key] = true;
                    if ((event.key === 'ArrowUp' || event.key === 'w' || event.key === ' ') && player.isGrounded) {
                        player.velocityY = -player.jumpStrength;
                        player.isGrounded = false;
                    }
                } else if (gameState === "gameOver") {
                    initializeGame();
                    runGame();
                }
            });

            window.addEventListener('keyup', function(event) {
                if (gameState === "playing") {
                    delete keysPressed[event.key];
                }
            });

            // --- Collision Detection ---
            function checkCollision(rect1, rect2) {
                return rect1.x < rect2.x + rect2.width &&
                       rect1.x + rect1.width > rect2.x &&
                       rect1.y < rect2.y + rect2.height &&
                       rect1.y + rect1.height > rect2.y;
            }

            // --- Game Over Function ---
            function triggerGameOver(cause) {
                if (gameState !== "playing") return;

                gameState = "gameOver";
                finalTime = (performance.now() - startTime) / 1000;
                displayTimeSeconds = finalTime; // Update displayTimeSeconds for final draw

                if (cause) {
                    gameovertext.textContent = `Hai vinto! Tempo: ${finalTime.toFixed(2)}s. Premi un tasto per rigiocare.`;
                } else {
                    gameovertext.textContent = `Hai perso! Tempo: ${finalTime.toFixed(2)}s. Premi un tasto per rigiocare.`;
                }
                console.log(`Game Over. Final Time: ${finalTime.toFixed(3)}s`);
                draw();
            }

            // --- Update Function ---
            function update() {
                if (gameState !== "playing") return;

                 for (let i = 0; i < platforms.length; i++) {
                    const p = platforms[i];
                    if (p.isMoving) {
                        p.x += p.moveSpeed * p.direction;
                        if (p.direction === 1 && p.x >= p.startX + p.moveRangeX) {
                            p.direction = -1; p.x = p.startX + p.moveRangeX;
                        } else if (p.direction === -1 && p.x <= p.startX) {
                            p.direction = 1;  p.x = p.startX;
                        }
                    }
                }

                // Determine player's intended horizontal movement from input
                player.dx = 0;
                if (keysPressed['ArrowLeft'] || keysPressed['a']) player.dx = -player.speed;
                if (keysPressed['ArrowRight'] || keysPressed['d']) player.dx = player.speed;

                let playerOnMovingPlatform = null;

                // Vertical movement & Collision
                player.velocityY += player.gravity;
                let oldPlayerY = player.y;
                let playerTargetY = player.y + player.velocityY;

                player.isGrounded = false;
                let landedOnGoal = false;

                for (let i = 0; i < platforms.length; i++) {
                    const platform = platforms[i];
                    const nextPlayerRect = {
                        x: player.x, // Use current player.x for vertical collision, horizontal adjusted later
                        y: playerTargetY,
                        width: player.width,
                        height: player.height
                    };

                    if (checkCollision(nextPlayerRect, platform)) {
                        if (player.velocityY >= 0 && (oldPlayerY + player.height) <= platform.y) {
                            player.y = platform.y - player.height;
                            player.velocityY = 0;
                            player.isGrounded = true;
                            if (platform.goal === true) landedOnGoal = true;
                            if (platform.isMoving) {
                                playerOnMovingPlatform = platform;
                            }
                            playerTargetY = player.y; // Update target if collision occurred
                            break;
                        }
                    }
                }
                player.y = playerTargetY;


                // --- HORIZONTAL POSITIONING ---
                // 1. If on a moving platform, first move the player with the platform
                if (playerOnMovingPlatform) {
                    player.x += playerOnMovingPlatform.moveSpeed * playerOnMovingPlatform.direction;
                }
                // 2. Then, apply the player's own intended movement (dx)
                player.x += player.dx;


                // Keep player within WORLD bounds (horizontal) after all X movements
                if (player.x < 0) player.x = 0;
                if (player.x + player.width > world.width) player.x = world.width - player.width;


                if (landedOnGoal) { triggerGameOver(true); return; }

                let landedOnFloor = false;
                if (!player.isGrounded && (player.y + player.height) >= world.height) {
                    player.y = world.height - player.height;
                    player.velocityY = 0;
                    player.isGrounded = true;
                    landedOnFloor = true;
                }
                if (landedOnFloor) { triggerGameOver(false); return; }

                if (player.y < 0 && player.velocityY < 0) { player.y = 0; player.velocityY = 0; }

                // Update Camera Position
                camera.x = (player.x + player.width / 2) - canvas.width / 2;
                if (camera.x < 0) camera.x = 0;
                if (camera.x + camera.width > world.width) camera.x = world.width - camera.width;
            }

            // --- Draw Function ---
            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                for (let i = 0; i < platforms.length; i++) {
                    const p = platforms[i];
                    if (p.x + p.width > camera.x && p.x < camera.x + camera.width &&
                        p.y + p.height > camera.y && p.y < camera.y + camera.height) {
                        ctx.fillStyle = p.color;
                        // For horizontal scrolling only, camera.y is 0
                        ctx.fillRect(p.x - camera.x, p.y - 0, p.width, p.height);
                    }
                }

                ctx.fillStyle = player.color;
                // For horizontal scrolling only, camera.y is 0
                ctx.fillRect(player.x - camera.x, player.y - 0, player.width, player.height);

                // Update displayTimeSeconds for drawing
                if (gameState === "playing") {
                    displayTimeSeconds = (performance.now() - startTime) / 1000;
                } else if (gameState === "gameOver") {
                    // displayTimeSeconds is already set by triggerGameOver
                } else { // initial state
                    displayTimeSeconds = 0;
                }


                ctx.font = "20px Arial"; ctx.fillStyle = "black";
                ctx.textAlign = "left"; ctx.textBaseline = "top";
                ctx.fillText(`Tempo: ${displayTimeSeconds.toFixed(2)}s`, 10, 10);

                if (gameState === "initial") {
                    ctx.font = "30px Arial"; ctx.fillStyle = "rgba(0,0,0,0.8)";
                    ctx.textAlign = "center"; ctx.textBaseline = "middle";
                    ctx.fillText("Premi un tasto per iniziare!", canvas.width / 2, canvas.height / 2);
                }
            }

            // --- Animation Loop ---
            function gameLoop() {
                if (gameState !== "playing") return;

                update();
                draw();
                requestAnimationFrame(gameLoop);
            }

            // --- Game Setup and Control Functions ---
            function initializeGame() {
                player.x = 50; player.y = 50;
                player.velocityY = 0; player.dx = 0;
                player.isGrounded = false;

                finalTime = 0;
                displayTimeSeconds = 0; // Reset display time too
                for (const key in keysPressed) delete keysPressed[key];

                gameovertext.textContent = "";
                // Reset camera for a fresh start
                camera.x = 0;
                camera.y = 0;
            }

            function runGame() {
                if (gameState === "playing") return;

                initializeGame();
                gameState = "playing";
                startTime = performance.now();
                console.log("Game Started!");
                gameLoop();
            }

            // --- Initial Page Load ---
            initializeGame();
            gameState = "initial";
            draw(); // Draw the initial screen

        } else {
            if (!ctx) console.error("Failed to get 2D context.");
            if (!gameovertext) console.error("Failed to find GameOverText element.");
            alert("Sorry, there was an error initializing the game.");
        }
    </script>
</body>
</html>